\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[brazilian]{babel}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{array}
\usepackage{multirow}
\usepackage{enumitem}
\usepackage{tikz}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{float}


% Configuração de página
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}

% Configuração de cores
\definecolor{codeblue}{RGB}{0,102,204}
\definecolor{codegray}{RGB}{128,128,128}
\definecolor{codegreen}{RGB}{0,128,0}
\definecolor{backcolour}{RGB}{245,245,245}

% Configuração de código VHDL
\lstdefinestyle{vhdlstyle}{
    backgroundcolor=\color{backcolour},
    commentstyle=\color{codegreen},
    keywordstyle=\color{codeblue}\bfseries,
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codegreen},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=b,
    keepspaces=true,
    numbers=left,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=false,
    tabsize=2,
    frame=single,
    language=VHDL
}
\lstset{style=vhdlstyle}

% Configuração de hyperlinks
\hypersetup{
    colorlinks=true,
    linkcolor=codeblue,
    urlcolor=codeblue,
    citecolor=codeblue
}

% Cabeçalho e rodapé
\pagestyle{fancy}
\fancyhf{}
\rhead{CPU RISC-V 32-bit Pipeline}
\lhead{Arquitetura de Computadores}
\rfoot{Página \thepage}

\begin{document}

%=============================================================================
% CAPA
%=============================================================================
\begin{titlepage}
    \centering
    \vspace*{2cm}
    
    {\LARGE \textbf{Universidade Federal do Rio de Janeiro}}\\[0.5cm]
    {\Large Centro de Tecnologia}\\[0.3cm]
    {\Large Escola Politécnica}\\[2cm]
    
    \rule{\linewidth}{0.5mm}\\[0.4cm]
    {\Huge \textbf{CPU RISC-V 32-bit Pipeline}}\\[0.2cm]
    {\Large RV32I - Relatório Técnico}\\
    \rule{\linewidth}{0.5mm}\\[2cm]
    
    \textbf{Autores:}\\[0.3cm]
    Breno Valente Manhães - DRE: 122038517\\
    Thomas Cardoso de Miranda - DRE: 122050797\\
    Murilo Jorge de Figueiredo - DRE: 122079597\\
    Gabriel Brígido Pinheiro da Silva - DRE: 120056519\\
    Carlos Bruno Barbosa Correia - DRE: 122039987\\[1cm]
    
    \textit{Disciplina: EEL580 - Arquitetura de Computadores}\\
    \textit{Professor: Diego Leonel Cadete Dutra}\\[2cm]
    
    \textbf{Repositório GitHub:}\\[0.2cm]
    \url{https://github.com/brenopprufrj/Trabalho_RiscV_Digital_Basic.git}\\[2cm]
    
    \vfill
    {\large Rio de Janeiro - RJ}\\
    {\large Janeiro de 2026}
\end{titlepage}

%=============================================================================
% SUMÁRIO
%=============================================================================
\tableofcontents
\newpage

%=============================================================================
% 1. INTRODUÇÃO
%=============================================================================
\section{Introdução}

Este relatório descreve a implementação de uma CPU RISC-V de 32 bits (RV32I) com arquitetura de pipeline de 5 estágios, desenvolvida em VHDL para uso no simulador Digital.

\subsection{Objetivos}

O objetivo deste projeto é projetar e implementar uma CPU RISC-V de 32 bits cuja microarquitetura seja baseada em um pipeline com 5 estágios, atendendo aos seguintes requisitos:

\begin{itemize}
    \item Pipeline com ao menos 5 estágios
    \item Memórias de instruções e dados distintas
    \item Cada memória entrega uma palavra por ciclo
    \item Memórias com carga de dados assíncrona
    \item CPU não opera durante carga de dados
    \item Sinal de reset funcional
    \item Implementação apenas do pipeline de inteiros (sem modo S)
    \item Sinais de debug para aferição de estados internos
\end{itemize}

\subsection{Instruções Suportadas}

A CPU implementa as 20 instruções RV32I especificadas:

\begin{itemize}
    \item \textbf{Aritméticas:} \texttt{add}, \texttt{addi}, \texttt{auipc}, \texttt{sub}
    \item \textbf{Lógicas:} \texttt{and}, \texttt{andi}, \texttt{or}, \texttt{ori}, \texttt{xor}, \texttt{xori}
    \item \textbf{Deslocamento:} \texttt{sll}, \texttt{slli}, \texttt{srl}, \texttt{srli}
    \item \textbf{Memória:} \texttt{lw}, \texttt{lui}, \texttt{sw}
    \item \textbf{Controle:} \texttt{jal}, \texttt{jalr}, \texttt{beq}, \texttt{bne}
\end{itemize}

%=============================================================================
% 2. ARQUITETURA DO PIPELINE
%=============================================================================
\section{Arquitetura do Pipeline}

\subsection{Visão Geral dos Estágios}

A CPU utiliza um pipeline clássico de 5 estágios:

\begin{table}[H]
\centering
\begin{tabular}{|c|c|l|}
\hline
\textbf{Estágio} & \textbf{Sigla} & \textbf{Função} \\
\hline
Instruction Fetch & IF & Busca instrução da memória ROM \\
Instruction Decode & ID & Decodifica instrução e lê registradores \\
Execute & EX & Executa operação na ALU \\
Memory Access & MEM & Acessa memória de dados \\
Write Back & WB & Escreve resultado no banco de registradores \\
\hline
\end{tabular}
\caption{Estágios do Pipeline}
\end{table}

\subsection{Registradores de Pipeline}

Os registradores de pipeline armazenam as informações entre os estágios:

\begin{itemize}
    \item \textbf{IF/ID} -- Armazena PC, PC+4 e instrução buscada
    \item \textbf{ID/EX} -- Armazena dados dos registradores, imediato e sinais de controle
    \item \textbf{EX/MEM} -- Armazena resultado da ALU e sinais de controle de memória
    \item \textbf{MEM/WB} -- Armazena dados para escrita no banco de registradores
\end{itemize}

\subsection{Diagrama do Pipeline}

A Figura \ref{fig:pipeline_simple} apresenta o diagrama simplificado do pipeline:

\begin{figure}[H]
\centering
\begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
    % Estágios Principais
    \node[draw, minimum width=1.5cm, minimum height=1cm] (IF) at (0,0) {IF};
    \node[draw, minimum width=1.5cm, minimum height=1cm] (ID) at (3,0) {ID};
    \node[draw, minimum width=1.5cm, minimum height=1cm] (EX) at (6,0) {EX};
    \node[draw, minimum width=1.5cm, minimum height=1cm] (MEM) at (9,0) {MEM};
    \node[draw, minimum width=1.5cm, minimum height=1cm] (WB) at (12,0) {WB};
    
    % Registradores de pipeline (Barras verticais)
    \node[draw, fill=gray!20, minimum width=0.8cm, minimum height=1.5cm] (IFID) at (1.5,0) {\rotatebox{90}{\tiny IF/ID}};
    \node[draw, fill=gray!20, minimum width=0.8cm, minimum height=1.5cm] (IDEX) at (4.5,0) {\rotatebox{90}{\tiny ID/EX}};
    \node[draw, fill=gray!20, minimum width=0.8cm, minimum height=1.5cm] (EXMEM) at (7.5,0) {\rotatebox{90}{\tiny EX/MEM}};
    \node[draw, fill=gray!20, minimum width=0.8cm, minimum height=1.5cm] (MEMWB) at (10.5,0) {\rotatebox{90}{\tiny MEM/WB}};
    
    % Conexões lineares
    \draw[->] (IF) -- (IFID);
    \draw[->] (IFID) -- (ID);
    \draw[->] (ID) -- (IDEX);
    \draw[->] (IDEX) -- (EX);
    \draw[->] (EX) -- (EXMEM);
    \draw[->] (EXMEM) -- (MEM);
    \draw[->] (MEM) -- (MEMWB);
    \draw[->] (MEMWB) -- (WB);
    
    % Caminho de Writeback (Loop de volta para o estágio ID)
    % Sai do WB, desce 1 unidade, vai para a esquerda até o ID e sobe
    \draw[->, dashed] (WB.south) -- ++(0,-1) -| (ID.south);

\end{tikzpicture}
\caption{Diagrama Simplificado dos Estágios do Pipeline}
\label{fig:pipeline_simple}
\end{figure}

%=============================================================================
% 3. ATENDIMENTO AOS REQUISITOS
%=============================================================================
\section{Atendimento aos Requisitos}

\subsection{Memórias Distintas}

\textbf{Requisito:} Memórias de instruções e dados separadas, cada uma entregando uma palavra por ciclo.

\textbf{Implementação:} Arquitetura Harvard com interfaces separadas:

\begin{lstlisting}[caption={Interface de Memórias}]
-- Memoria de Instrucoes (ROM)
imem_addr_o  : out std_logic_vector(31 downto 0);
imem_data_i  : in  std_logic_vector(31 downto 0);

-- Memoria de Dados (RAM)
dmem_addr_o  : out std_logic_vector(31 downto 0);
dmem_wdata_o : out std_logic_vector(31 downto 0);
dmem_rdata_i : in  std_logic_vector(31 downto 0);
dmem_we_o    : out std_logic;
\end{lstlisting}

\subsection{Carga Assíncrona de Memória}

\textbf{Requisito:} Memórias com carga assíncrona; CPU não opera durante carga.

\textbf{Implementação:} O sinal \texttt{load\_enable\_i} controla o estado da CPU:

\begin{itemize}
    \item \texttt{load\_enable\_i = '1'}: CPU pausada, permite carga de memória
    \item \texttt{load\_enable\_i = '0'}: CPU operando normalmente
\end{itemize}

\begin{lstlisting}[caption={Controle de Carga}]
if load_enable_i = '0' then
    -- CPU ativa, atualiza registradores
else
    -- CPU pausada, mantem estado
end if;

-- Escrita bloqueada durante carga
dmem_we_o <= mem_mem_write and (not load_enable_i);
\end{lstlisting}

\subsection{Sinal de Reset}

\textbf{Requisito:} CPU deve possuir sinal de reset.

\textbf{Implementação:} Reset síncrono ativo em nível alto (\texttt{reset\_i = '1'}):

\begin{itemize}
    \item Zera o Program Counter (PC = 0x00000000)
    \item Limpa todos os registradores de pipeline
    \item Insere NOPs em todos os estágios
\end{itemize}

\subsection{Instruções Implementadas}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|l|}
\hline
\textbf{Tipo} & \textbf{Instruções} & \textbf{Implementação} \\
\hline
Aritméticas & add, addi, auipc, sub & ALU com operações ADD/SUB \\
Lógicas & and, andi, or, ori, xor, xori & ALU com operações AND/OR/XOR \\
Deslocamento & sll, slli, srl, srli & ALU com shift left/right \\
Memória & lw, lui, sw & Load/Store word \\
Controle & jal, jalr, beq, bne & Jumps e branches condicionais \\
\hline
\end{tabular}
\caption{Instruções Implementadas}
\end{table}

%=============================================================================
% 4. ESCOLHAS DE PROJETO
%=============================================================================
\section{Escolhas de Projeto}

\subsection{Tratamento de Hazards}

\subsubsection{Data Hazards (RAW)}

\begin{itemize}
    \item \textbf{Forwarding Unit:} Encaminha dados dos estágios MEM e WB para EX, evitando stalls desnecessários
    \item \textbf{Stall para Load-Use:} Insere bolha quando há dependência imediata de LW
\end{itemize}

\subsubsection{Control Hazards}

\begin{itemize}
    \item Branches são resolvidos no estágio EX
    \item Flush de instruções em IF e ID quando branch é tomado
\end{itemize}

\subsection{Geração de Imediatos}

O Instruction Decoder gera imediatos sign-extended para todos os formatos:

\begin{itemize}
    \item \textbf{I-type:} 12 bits $\rightarrow$ 32 bits
    \item \textbf{S-type:} 12 bits (separados) $\rightarrow$ 32 bits
    \item \textbf{B-type:} 13 bits (bit 0 = 0) $\rightarrow$ 32 bits
    \item \textbf{U-type:} 20 bits $\rightarrow$ 32 bits (bits inferiores = 0)
    \item \textbf{J-type:} 21 bits (bit 0 = 0) $\rightarrow$ 32 bits
\end{itemize}

\subsection{Sinais de Debug}

Para aferição de estados internos, conforme requisitado:

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Sinal} & \textbf{Descrição} \\
\hline
\texttt{pc\_debug\_o} & Valor atual do PC \\
\texttt{instr\_debug\_o} & Instrução no estágio ID \\
\texttt{alu\_result\_debug\_o} & Resultado da ALU \\
\texttt{reg\_debug\_o} & Valor de registrador selecionado \\
\texttt{stage\_if/id/ex\_pc\_o} & PC em cada estágio \\
\texttt{hazard\_stall\_o} & Indicador de stall \\
\texttt{hazard\_flush\_o} & Indicador de flush \\
\hline
\end{tabular}
\caption{Sinais de Debug}
\end{table}

Módulos individuais também exportam sinais internos:
\begin{itemize}
    \item \textbf{ALU:} \texttt{carry\_o}, \texttt{overflow\_o}
    \item \textbf{Branch Comparator:} \texttt{eq\_o}, \texttt{ne\_o}
    \item \textbf{Hazard Unit:} \texttt{hazard\_type\_o}
\end{itemize}

%=============================================================================
% 5. ESTRUTURA DE ARQUIVOS
%=============================================================================
\section{Estrutura de Arquivos}

\begin{table}[H]
\centering
\begin{tabular}{|l|l|}
\hline
\textbf{Arquivo} & \textbf{Descrição} \\
\hline
\texttt{riscv\_cpu.vhd} & Módulo top-level \\
\texttt{program\_counter.vhd} & Contador de programa \\
\texttt{instruction\_decoder.vhd} & Decodificador + gerador de imediatos \\
\texttt{control\_unit.vhd} & Unidade de controle \\
\texttt{register\_file.vhd} & Banco de 32 registradores \\
\texttt{alu.vhd} & Unidade lógico-aritmética \\
\texttt{pipeline\_regs.vhd} & Registradores IF/ID, ID/EX, EX/MEM, MEM/WB \\
\texttt{hazard\_unit.vhd} & Detecção de hazards \\
\texttt{forwarding\_unit.vhd} & Data forwarding \\
\texttt{branch\_comparator.vhd} & Comparador para branches \\
\texttt{Circuito.dig} & Circuito montado no simulador Digital \\
\texttt{TUTORIAL\_SETUP.md} & Tutorial de configuração \\
\hline
\end{tabular}
\caption{Arquivos do Projeto}
\end{table}

%=============================================================================
% 6. CONCLUSÃO
%=============================================================================
\section{Conclusão}

A implementação atende a todos os requisitos especificados:

\begin{itemize}
    \item[$\checkmark$] Pipeline de 5 estágios (IF, ID, EX, MEM, WB)
    \item[$\checkmark$] Memórias de instruções e dados separadas
    \item[$\checkmark$] Uma palavra por ciclo em cada memória
    \item[$\checkmark$] Carga assíncrona de memória
    \item[$\checkmark$] CPU pausa durante carga (\texttt{load\_enable\_i})
    \item[$\checkmark$] Sinal de reset funcional
    \item[$\checkmark$] Todas as 20 instruções RV32I implementadas
    \item[$\checkmark$] Apenas pipeline de inteiros (sem modo S)
    \item[$\checkmark$] Sinais de debug para aferição de estados internos
\end{itemize}

O projeto está disponível no repositório GitHub para consulta e reprodução.

%=============================================================================
% REFERÊNCIAS
%=============================================================================
\section*{Referências}
\addcontentsline{toc}{section}{Referências}

\begin{enumerate}
    \item RISC-V Foundation. \textit{The RISC-V Instruction Set Manual, Volume I: User-Level ISA}. Disponível em: \url{https://riscv.org/specifications/}
    \item Neemann, H. \textit{Digital - A digital logic designer and circuit simulator}. Disponível em: \url{https://github.com/hneemann/Digital}
    \item GHDL. \textit{GHDL - Open-source VHDL simulator}. Disponível em: \url{https://github.com/ghdl/ghdl}
    \item Patterson, D. A.; Hennessy, J. L. \textit{Computer Organization and Design: The Hardware/Software Interface}. Morgan Kaufmann, 2020.
\end{enumerate}

%=============================================================================
% APÊNDICE A: REFERÊNCIA DE INSTRUÇÕES
%=============================================================================
\newpage
\appendix
\section{Referência de Instruções}
\label{apendice:instrucoes}

Esta seção apresenta a documentação completa de opcodes e instruções suportadas pela CPU RISC-V RV32I implementada.

\subsection{Tabela de Opcodes}

\begin{table}[H]
\centering
\begin{tabular}{|c|c|c|l|}
\hline
\textbf{Opcode (Bin)} & \textbf{Opcode (Hex)} & \textbf{Tipo} & \textbf{Instruções} \\
\hline
0110011 & 0x33 & R & add, sub, and, or, xor, sll, srl \\
0010011 & 0x13 & I & addi, andi, ori, xori, slli, srli \\
0000011 & 0x03 & I & lw \\
0100011 & 0x23 & S & sw \\
1100011 & 0x63 & B & beq, bne \\
1101111 & 0x6F & J & jal \\
1100111 & 0x67 & I & jalr \\
0110111 & 0x37 & U & lui \\
0010111 & 0x17 & U & auipc \\
\hline
\end{tabular}
\caption{Tabela de Opcodes RV32I}
\label{tab:opcodes}
\end{table}

\subsection{Formatos de Instrução}

\begin{table}[H]
\centering
\small
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
\textbf{Formato} & \textbf{[31:25]} & \textbf{[24:20]} & \textbf{[19:15]} & \textbf{[14:12]} & \textbf{[11:7]} & \textbf{[6:0]} \\
\hline
R & funct7 & rs2 & rs1 & funct3 & rd & opcode \\
I & \multicolumn{2}{c|}{imm[11:0]} & rs1 & funct3 & rd & opcode \\
S & imm[11:5] & rs2 & rs1 & funct3 & imm[4:0] & opcode \\
B & imm[12,10:5] & rs2 & rs1 & funct3 & imm[4:1,11] & opcode \\
U & \multicolumn{4}{c|}{imm[31:12]} & rd & opcode \\
J & \multicolumn{4}{c|}{imm[20,10:1,11,19:12]} & rd & opcode \\
\hline
\end{tabular}
\caption{Formatos de Instrução RISC-V}
\label{tab:formatos}
\end{table}

\subsection{Instruções Aritméticas e Lógicas}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|c|l|}
\hline
\textbf{Instrução} & \textbf{Tipo} & \textbf{Opcode} & \textbf{funct3} & \textbf{funct7} & \textbf{Operação} \\
\hline
add & R & 0110011 & 000 & 0000000 & rd = rs1 + rs2 \\
sub & R & 0110011 & 000 & 0100000 & rd = rs1 - rs2 \\
addi & I & 0010011 & 000 & - & rd = rs1 + imm \\
auipc & U & 0010111 & - & - & rd = PC + (imm $\ll$ 12) \\
and & R & 0110011 & 111 & 0000000 & rd = rs1 \& rs2 \\
or & R & 0110011 & 110 & 0000000 & rd = rs1 | rs2 \\
xor & R & 0110011 & 100 & 0000000 & rd = rs1 $\oplus$ rs2 \\
andi & I & 0010011 & 111 & - & rd = rs1 \& imm \\
ori & I & 0010011 & 110 & - & rd = rs1 | imm \\
xori & I & 0010011 & 100 & - & rd = rs1 $\oplus$ imm \\
\hline
\end{tabular}
\caption{Instruções Aritméticas e Lógicas}
\label{tab:arit_logic}
\end{table}

\subsection{Instruções de Deslocamento}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|c|l|}
\hline
\textbf{Instrução} & \textbf{Tipo} & \textbf{Opcode} & \textbf{funct3} & \textbf{funct7} & \textbf{Operação} \\
\hline
sll & R & 0110011 & 001 & 0000000 & rd = rs1 $\ll$ rs2[4:0] \\
srl & R & 0110011 & 101 & 0000000 & rd = rs1 $\gg$ rs2[4:0] \\
slli & I & 0010011 & 001 & 0000000 & rd = rs1 $\ll$ shamt \\
srli & I & 0010011 & 101 & 0000000 & rd = rs1 $\gg$ shamt \\
\hline
\end{tabular}
\caption{Instruções de Deslocamento}
\label{tab:shift}
\end{table}

\subsection{Instruções de Memória}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|l|}
\hline
\textbf{Instrução} & \textbf{Tipo} & \textbf{Opcode} & \textbf{funct3} & \textbf{Operação} \\
\hline
lw & I & 0000011 & 010 & rd = MEM[rs1 + imm] \\
sw & S & 0100011 & 010 & MEM[rs1 + imm] = rs2 \\
lui & U & 0110111 & - & rd = imm $\ll$ 12 \\
\hline
\end{tabular}
\caption{Instruções de Memória}
\label{tab:mem}
\end{table}

\subsection{Instruções de Controle de Fluxo}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|c|c|l|}
\hline
\textbf{Instrução} & \textbf{Tipo} & \textbf{Opcode} & \textbf{funct3} & \textbf{Operação} \\
\hline
beq & B & 1100011 & 000 & if (rs1 == rs2) PC += imm \\
bne & B & 1100011 & 001 & if (rs1 != rs2) PC += imm \\
jal & J & 1101111 & - & rd = PC+4; PC += imm \\
jalr & I & 1100111 & 000 & rd = PC+4; PC = (rs1 + imm) \& $\sim$1 \\
\hline
\end{tabular}
\caption{Instruções de Controle de Fluxo}
\label{tab:control}
\end{table}

\subsection{Códigos de Controle da ALU}

\begin{table}[H]
\centering
\begin{tabular}{|l|c|l|l|}
\hline
\textbf{Nome} & \textbf{Código} & \textbf{Operação} & \textbf{Descrição} \\
\hline
ALU\_ADD & 0000 & A + B & Soma \\
ALU\_SUB & 0001 & A - B & Subtração \\
ALU\_AND & 0010 & A \& B & AND bit-a-bit \\
ALU\_OR & 0011 & A | B & OR bit-a-bit \\
ALU\_XOR & 0100 & A $\oplus$ B & XOR bit-a-bit \\
ALU\_SLL & 0101 & A $\ll$ B[4:0] & Shift left logical \\
ALU\_SRL & 0110 & A $\gg$ B[4:0] & Shift right logical \\
ALU\_PASS\_B & 0111 & B & Passa operando B (LUI) \\
\hline
\end{tabular}
\caption{Códigos de Controle da ALU}
\label{tab:alu_ctrl}
\end{table}

\subsection{Exemplos de Codificação}

\textbf{Exemplo 1: \texttt{addi x1, x0, 5}} -- Carrega o valor 5 no registrador x1.
\begin{verbatim}
imm[11:0] = 000000000101 (5)
rs1       = 00000 (x0)
funct3    = 000
rd        = 00001 (x1)
opcode    = 0010011

Hex: 0x00500093
\end{verbatim}

\textbf{Exemplo 2: \texttt{add x3, x1, x2}} -- Soma x1 + x2 e armazena em x3.
\begin{verbatim}
funct7    = 0000000
rs2       = 00010 (x2)
rs1       = 00001 (x1)
funct3    = 000
rd        = 00011 (x3)
opcode    = 0110011

Hex: 0x002081B3
\end{verbatim}

\end{document}
